# CH3-2

## 상속: 재사용 + 확장

객체 지향에서 상속은 상위 클래스의 특성을 하위 클래스에서 상속(**특성** 상속) 하고 거기에 더해 필요한 **특성을 추가, 확장**해서 사용할 수 있다는 의미

⇒ 부모 자식의 관계보다 확장, 세분화, 슈퍼(상위)클래스-서브(하위)클래스의 개념

![Untitled](CH3-2%20a868c19cff7f425580735d2dd7d9784d/Untitled.png)

출처 : [ 스프링 입문을 위한 자바 객체지향의 원리와 이해]

즉, 상속의 개념이 조직도나 계층도가 아닌 분류도  (inheritance 보단 extends)

참고, 클래스 명은 분류스럽게, 객체 참조 변수 명은 유일무이한 사물처럼 작명할 것!

### 상속의 강력함

```java
동물[] animals = new 동물[7];

		animals[0] = new 동물();
		animals[1] = new 포유류();
		animals[2] = new 조류();
		animals[3] = new 고래();
		animals[4] = new 박쥐();
		animals[5] = new 참새();
		animals[6] = new 펭귄();

		for (int index = 0; index < animals.length; index++) {
			animals[index].showMe();
		}
```

- "하위 클래스는 상위 클래스다."  ⇒ 동물 bird = new 조류();
- 하위클래스에서 메서드를 다시 작성하지 않아도 상위 클래스의 메서드를 호출 할 수 있다.
- toString() 메서드 또한 클래스 상속 주고에서 최상위 클래스인 Object 클래스의 메서드를 물려받아 사용 하는 것

객체 지향의 상속을 정리하자면,

- 객체 지향의 상속은 상위 클래스의 특성을 재사용 하는 것
- 객체 지향의 상속은 상위클래스의 특성을 확장하는 것
- 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.

### 다중 상속과 자바

- 다중 상속된 클래서가 상위 클래스의 메서드 들 중 어떠한 메서드를 사용해야 할지 컴파일 과정에서 충돌이 생기는 것을 다이아 몬드 문제라 한다.
    
    ⇒ 자바와 C++에서 이러한 문제로 다중 상속을 지원하지 않는다.
    

### 상속과 인터페이스

인터 페이스는 클래스가 ' 무엇을 할 수 있다(be able to)' 라고 하는 기능을 구현하도록 강제 하게 된다. 

⇒ 인터페이스는 추상 메서드를 제공하고 구현을 구현클래스에서 하도록 강제 하기 때문에 다중 인테페이스를 지원한다.

결론 : 상위 클래스는 물려줄 특성이 풍성할수록 좋고(LSP), 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋다!(ISP)

참고, 

- 리스코프 치환 원칙 (LSP: Liskov Substitution Principle)
    
    : 'B가 A의 하위 클래스이면 상위 클래스의 A 객체는하위 클래스의 B로 치환해도, 작동에 문제가 없어야 한다'.
    
- 인터페이스 분리 원칙 - ISP (Interface Segregation Principal)
    
    :  클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙으로, 이 원칙은 큰 덩어리의 인터페이스들은 구체적이고 작은 단위들로 분리 시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다. 인터페이스 분리 원칙을 통해 시스템의 내부 의존성을 약화시켜 리팩토링, 수정, 재배포를 쉽게 할 수 있다.
    

상속과 UML 표기법

![Untitled](CH3-2%20a868c19cff7f425580735d2dd7d9784d/Untitled%201.png)

### 상속과 T 메모리

중요! 하위 클래스의 인스턴스가 생성될때 상위 클래스의 인스턴스도 함께 생성된다.

main() 메서드에서

```java
Penguin pororo = new Penguin();
```

![Untitled](CH3-2%20a868c19cff7f425580735d2dd7d9784d/Untitled%202.png)

⇒ 부가설명 : Penguin 클래스는 Animal 클래스를 상속 받고 있다.

- 위와 같이 상위 클래스인 Animal 인스턴스도 힙 메모리에 생성된다.
- 그림에는 표현이 되지않았지만 Object 클래스의 인스턴스도 함께 생성된다.
- 다만, Animal pingu = new Penguin(); 과 같이 생성한 경우 객체 참조는 Animal 클래스로 하게 된다.

### 다형성: 사용 편의성

1. 오버라이딩과 오버 로딩
    - 오버라이딩 : (재정의) 상위 클래스의 메서드와 같은 메서드 이름, 같은 인자 리스트
    - 오버 로딩 : (중복정의) 같은 메서드 이름, 다른 인자 리스트
    
2. 다형성과 T 메모리
    - 중요! : 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩(재정의) 한 메서드가 호출
        
        ⇒ Animal pororo = new Penguin();
        
        ⇒ pororo.showName();
        
        ⇒ Animal 클래스에 정의된 showName() 메서드가 아닌 Penguin 클래스에 재정의된 showName() 메서드가 실행
        

### 캡슐화 : 정보 은닉

**1. 객체 멤버와 정적 멤버의 접근 제어자**

- 접근 제어자
    - private : 본인만 접근 가능
    - default : 같은 패키지 내의 클래스에서 접근 가능
    - protected : 상속받은 클래스 또는 같은 패키지 내의 클래스에서 접근 가능
    - public : 모두가 접근 가능
- 상속받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야한다.
- 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.
    - 일관된 형식으로 접근하기 위해서
    - 물리적 접근에 따른 이유

**2. 참조 변수의 복사**

- 기본 자료형 변수는 값을 값 자체로 판단한다
- 참조 자료형 변수는 값을 주소(포인터)로 판단한다