## 객체 지향 설계 5원칙 - SOLID

- 객체 지향의 특성을 올바르게 사용하는 방법
- 객체 지향 언어를 이용해 객체 지향 프로그램을 올바르게 설계해 나가는 방법이나 원칙

`응집도(cohesion)는 높이고, 결합도(coupling)는 낮추라`는 고전 원칙을 객체 지향의 관점에서 재정립한 것

SOLID는 객체 지향 프로그램을 구성하는 속성, 메서드, 클래스, 객체, 패키지, 모듈, 라이브러리, 프레임워크, 아키텍처 등 다양한 곳에 다양하게 적용되는 것이기에 막상 SOLID가 적용됐는지 아닌지 애매모호하거나 보는 사람의 관점에 따라 다르게 해석될 수 있는 소지가 있다. - 제품이 아닌 `개념`이기에 그렇다.

### SRP - 단일 책임 원칙

'어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.'

역할과 책임이 너무 많은 클래스 - 객체 지향 세계에서는 `나쁜 냄새`가 난다고 한다.

-> **역할(책임)을 분리**하라는 것이 단일 책임 원칙이다.

단일 책임 원칙은 속성, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크 등에도 적용할 수 있는 개념이다.

**단일 책임 원칙을 지키지 못하는 경우**

- 속성이 단일 책임 원칙을 지키지 못하는 경우
  - 클래스 간의 공통점이 없다면 상위 클래스를 제거
  - 공통점이 많다면 상위 클래스에 공통점을 두고 상위 클래스를 상속하고 차이점만 각자 구현
- 하나의 속성이 여러 의미를 갖는 경우
  - 자바 코드에 if 문을 여기저기 사용
  - 클래스가 아닌 데이터베이스 테이블을 설계할 때도 단일 책임 원칙을 고려해야 한다. -> `정규화`
- 메서드가 단일 책임 원칙을 지키지 못하는 경우
  - 하나의 메서드가 여러 행위를 모두 구현하려고 할 때
  - 대표적인 나쁜 냄새가 **'분기 처리를 위한 if 문'**
  - 예제 : 강아지가 수컷이냐 암컷이냐에 따라 소변보다() 메서드의 행위가 달라지는데, 강아지 클래스에서 모두 구현하려고 할 때 SRP 위배 -> 수컷, 암컷 클래스를 하위 클래스로, 각 클래스에서 소변보다() 메서드를 구현

단일 책임 원칙과 가장 관계가 깊은 것은 `모델링 과정을 담당하는 추상화`

- 애플리케이션의 경계를 정하고 추상화를 통해 클래스들을 선별하고 속성과 메서드를 설계할 때 반드시 단일 책임 원칙을 고려하는 습관을 들이자
- 리팩터링을 통해 코드를 개선할 때 단일 책임 원칙을 적용할 곳이 있는지 꼼꼼히 살피자



### OCP - 개방 폐쇄 원칙

'소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다.'

-> '자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.'

상위 클래스 또는 인터페이스를 중간에 둠으로써 다양한 자동차가 생긴다고 해도 객체 지향 세계의 운전자는 운전 습관에 영향을 받지 않게 된다. 다양한 자동차가 생긴다고 하는 것은 자동차 입장에서는 자신의 확장에서는 개방돼 있는 것이고, 운전자 입장에서는 주변의 변화에 폐쇄돼 있는 것이다.

- JDBC - 클라이언트는 데이터베이스가 오라클에서 MySQL로 바뀌더라도 Connection을 설정하는 부분 외에는 따로 수정할 필요가 없다.
- 자바 - 개발자는 다양한 구동 환경에 대해서는 걱정하지 않고 본인이 작업하고 있는 개발 PC에 설치된 JVM에서 구동되는 코드만 작성하면 된다. -> 소스코드는 운영체제의 변화에 닫혀 있고, 각 운영체제별 JVM은 확장에 열려있는 구조가 되는 것

개방 폐쇄 원칙을 따르지 않는다고 해서 객체 지향 프로그램을 구현하는 것이 불가능한 것은 아니지만 개방 폐쇄 원칙을 무시하고 프로그램을 작성하면 객체 지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 없다. -> 개방 폐쇄 원칙은 반드시 지켜야 할 원칙이다.



### LSP - 리스코프 치환 원칙

'서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다.'

객체 지향에서의 상속은 조직도나 계층도가 아닌 **분류도**가 돼야 한다.

객체 지향의 상속은 아래의 조건을 만족해야 한다.

- 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.
- 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다.

=> 두 조건대로 구현된 프로그램이라면 리스코프 치환 원칙을 잘 지키고 있다고 할 수 있다.

위 조건대로 구현되지 않은 코드 : 상속이 조직도나 계층도 형태로 구축된 경우

'하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.'

리스코프 치환 원칙은 객체 지향의 상속이라는 특성을 올바르게 활용하면 자연스럽게 얻게 되는 것이다.

> 상속이 잘못 적용됐을 때 발생하는 문제점 
>
> 1. 계속되는 기능 확장으로 자식 클래스에 사용되는 기능을 모두 부모 클래스에 두어 확장과 수정이 어려워지고, 가독성을 떨어뜨린다.
> 2. 구현 클래스를 수정하기 어렵게 만들고, 부모 클래스의 수정이 자식 클래스에도 영향을 미치게 된다.

- 하위형에서 선행 조건은 강화될 수 없다.
- 하위형에서 후행 조건은 약화될 수 없다.
- 하위형에서 상위형의 불변 조건은 반드시 유지돼야 한다.



### ISP - 인터페이스 분리 원칙

'클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.'

단일 책임 원칙에서의 해결책은 하나의 클래스를 토막내서 하나의 역할(책임)만 하는 다수의 클래스로 분할하는 것이었다. 

-> 인터페이스 분할 원칙의 핵심 : 여러 상황에서 각각의 상황에 맞는 역할만 할 수 있게 인터페이스로 제한한다.

- 단일 책임 원칙과 인터페이스 분할 원칙은 **같은 문제에 대한 두 가지 다른 해결책**이라고 볼 수 있다.
- 프로젝트 요구사항과 설계자의 취향에 따라 단일 책임 원칙이나 인터페이스 분할 원칙 중 하나를 선택해서 설계할 수 있다.
- 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이라고 할 수 있다.

**인터페이스 최소주의 원칙** : 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하라는 것

인터페이스 최소주의가 가진 장점 : 인터페이스는 그 역할에 충실한 최소한의 기능만 공개



### DIP - 의존 역전 원칙

- '고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 **추상화**된 것에 의존해야 한다'
- '추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.'
- '자주 변경되는 구체 클래스에 의존하지 마라'

더 자주 변하는 구체 클래스에 의존 X -> 추상화된 인터페이스에만 의존하게 만들어서 다른 구체 클래스로 변경돼도 그 영향을 받지 않는 형태로 구성 - 개방 폐쇄 원칙(OCP)과 유사

그 무엇에도 의존하지 않는 클래스 -> 인터페이스에 의존 => 의존의 방향이 역전된 것

자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역전 원칙이다.

**'자신보다 변하기 쉬운 것에 의존하지 마라.'**

상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 **하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스를 통해 의존하라는 것**이 의존 역전 원칙이다.



### SoC(Seperation of Concerns) 관심사의 분리

- 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리하라는 것
- 하나의 속성, 하나의 메서드, 하나의 클래스, 하나의 모듈, 또는 하나의 패키지에는 하나의 관심사만 들어있어야 한다는 것
- SoC를 적용하면 자연스럽게 SRP, ISP, OCP에 도달하게 된다.

