# ch6 : 객체 지향 설계 5원칙 - SOLID

**객체 지향의 개념과 4대 특성**은 객체지향 프로그램을 작성할 수 있는 도구라 할수 있다. 도구를 잘 사용하는 방법(객체지향의 특성을 올바르게 사용하는 방법), 즉 **객체 지향 언어를 이용해 객체 지향 프로그램을 올바르게 설계해 나가는 방법이나 원칙**으로는 **SOLID** 가 있다.

📌**SOLID** : 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙으로 앞 알파벳을 따서 부르는 이름

- **SRP (Single Responsibility Principle) 단일 책임 원칙**
- **OCP (Open Closed Principle) 개방 폐쇄 원칙**
- **LSP (Liskov Substitution Principle) 리스코프 치환 원칙**
- **ISP (Interface Segregation Principle) 인터페이스 분리 원칙**
- **DIP (Dependency Inversion Principle) 의존 역전 원칙**

→ **응집도는 높이고, 결합도는 낮추라는** 고전 원칙을 객체 지향의 관점에서 재정립

❗결합도와 응집도

- **결합도** : 모듈(클래스) 간의 상호 의존 정도로서 결합도가 낮으면 모듈간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이
- **응집도 :** 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이

## 1. **SRP : 단일 책임 원칙**

- 모든 클래스는 **단 한 가지의 책임만을 가지고**, 클래스 안에 정의되어 있는 모든 기능은 하나의 책임을 수행하는데 집중되어 있어야 한다.
- 클래스를 **변경하는 이유**는 단 한개여야 한다. → 변경을 유발하는 **행위자**가 명확해야 한다.
- 하나의 속성이 **여러 의미를 갖는 경우**가 존재하면 안된다.
- 메서드가 단일 책임 원칙을 지키지 않을 경우 나타내는 대표적인 문제가 **분기 처리를 위한 if 문 사용**

## 2. OCP : 개방 폐쇄 원칙

- "소프트웨어 엔티티(클래스, 모듈, 함수 등) 는 **자신의 확장에 대해서는 열려 있어야 하지만 주변의 변경에 대해서는 닫혀 있어야 한다**."
- 기능을 확장하거나 변경할때 그것을 사용하는 코드는 수정하지 않는다.
- 상위 클래스 또는 인터페이스를 **완충장치로 사용**
- 장점 : 유연성, 재사용성, 유지보수성

❗**모든** 클래스의 결합 관계를 상위클래스나 인터페이스를 두고 느슨한 관계로 유지해야 할까??

→ 모든 확장에 대하여 예측을 미리 할 수 없으니 명확하게 확장이나 변경이 예상되는 시점에 적용하는 것이 좋지 않을까 생각합니다.

## 3. **LSP : 리스코프 치환 원칙**

- 상속과 인터페이스
    - 하위 클래스 **is a kind of** 상위 클래스 - 하위 분류는 상위 분류의 **한 종류다.**
    - 구현 클래스 **is able to** 인터페이스 - 구현 분류는 인터페이스 **할 수 있어야** 한다.
    - 객체지향에서 상속은 **조직도나 계층도가 아닌 분류도**여야 한다.

즉, 상속과 인터페이스의 특성을 지켜 관계를 구현한다면 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 **상위 클래스의 인스턴스 역할을 하는데** 문제가 없어야 한다.

- 하위형에서 선행 조건 은 강화될 수 없다.
    
    → 선행 조건 : 상위 클래스에서의 인자값에 대한 규칙
    
- 하위형에서 후행조건은  약화될 수 없다.
    
    → 후행 조건 : 상위 클래스에서 구현한 함수 종료 시점에 전달될 객체 값이 유효한 값인지 검사
    
- 하위형에서 상위형의 불변 조건은 반드시 유지돼야 한다.

## 4. **ISP : 인터페이스 분리 원칙**

- 클래이언트는 **자신이 사용하지 않는 메서드에** 의존 관계를 맺으면 안된다.
- SRP와 ISP는 같은 문제에 대한 두가지 다른 해결 책
    
    → 요구사항과 설계자의 취행에 따라 선택할 수 있지만 특별한 경우가 아니라면 단일 책임 원칙을 적용하는것이 더 좋은 해결책
    
- **상위 클래스는 풍성할수록 좋고, 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공**
    - 인터페이스는 그 역할에 충실한 최소한의 기능만 공개
    - 상위 클래스형의 참조 변수를 이용해야 상속의 가장 큰 혜택을 볼 수 있다.

## 5. **DIP : 의존 역전 원칙**

- "**고차원 모듈은 저차원 모듈에** 의존하면 안된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.
- "**추상화된 것은 구체적인 것에** 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다."
- "**자주 변경되는 구체 클래스에** 의존하지 마라 "

즉, 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변**하기 쉬운 것의 변화에 영향받지 않게 하는 것**이 의존 역전 원칙이다.

## ❗ SoC(Separation Of Concerns) : 관심사의 분리

관심사가 다르고 변화의 시기가 다르면 불리해야 하고 하나의 속성, 메서드, 클래스, 모듈, 패키지에는 하나의 관심사만 들어 있어야 한다. 

❗ SOLID 원칙을 적용하면 소스 파일의 개수는 더 많아지는 경향이 있다. 하지만 이렇게 많아진 파일이 논리를 더욱 잘 분할하고, 잘 표현하기에 명확하며 직관적이고, 유지와 관리, 보수하기 쉬운 소스가 만들어진다.