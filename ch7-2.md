## AOP

Aspect-Oriented Programming 관점 지향 프로그래밍

스프링 AOP는 로직(code) 주입이라고 할 수 있다.

다수의 모듈에 공통적으로 나타나는 부분이 존재하는데, 이것을 **횡단 관심사(corss-cutting concern)**라고 한다.

횡단 관심사는 모듈별로 반복되어 중복해서 나타나는 부분이다. -> 반복/중복은 분리해서 한 곳에서 관리!

**AOP를 통해 횡단 관심사를 분리, 분리된 횡단 관심사(로직)을 실행 시간에 메서드에 주입** (런타임에 로직 주입)

객체 지향에서 로직(코드)이 있는 곳은 **메서드의 안쪽**이다. 

메서드에서 코드를 주입할 수 있는 곳

- Around - 메서드 전 구역
- Before - 메서드 시작 전(메서드 시작 직후)
- After - 메서드 종료 후(메서드 종료 직전)
- AfterReturning - 메서드 정상 종료 후
- AfterThrowing - 메서드에서 예외가 발생하면서 종료된 후



인터페이스 기반으로 스프링 AOP 적용 - 인터페이스 없이 CGLib 라이브러리를 이용하는 방법도 있긴 하지만 귀찮은 설정 작업이 필요하다. (인터페이스를 만드는 것이 오히려 편하다.)

> CGLib(Code Generator Library) : 클래스의 바이트코드를 조작하여 Proxy 객체를 생성해주는 라이브러리

```java
@Component
@Aspect
public class MyAsepct {
  @Before("execution(* runSomething())")
  public void before(JoinPoint joinPoint) {
    System.out.println("얼굴 인식 확인 : 문 개방");
  }
}
```

```java
// AOP 적용 전

public class Boy {
  public void runSomething() {
    System.out.println("열쇠로 문 열고 집에 들어감");
  }
  
  try {
    System.out.println("컴퓨터 게임");
  } catch {
    System.out.println("119에 신고한다.");
  } finally {
    System.out.println("소등하고 잔다.");
  }
  
  System.out.println("문을 잠그고 집을 나선다.");
}
```

```java
// AOP 적용 후

public interface Person {
  void runSomething();
}

// 인터페이스 구현
public class Boy implements Person {
  public void runSomething() {
    System.out.println("컴퓨터로 게임을 한다.");
  }
}
```

AOP 적용 결과

- 횡단 관심사는 모두 사라지고 핵심 관심사만 남게 된다.
- 추가 개발과 유지보수 관점에서 보면 편한 코드가 된다.
- 단일 책임 원칙(SRP)을 자연스럽게 적용하게 된다.

CGLib를 사용하게 되면 인터페이스 없이도 AOP를 적용할 수 있지만 추천하는 방법은 아니다. 

CGLib를 사용할 경우는 코드를 변경할 수 없는 서드파티 모듈 안에 final로 선언된 클래스에 AOP를 적용해야 하는 경우 정도다.

- XML 기반 - `<aop:aspectj-autoproxy />` : 프록시 패턴을 이용해 횡단 관심사를 핵심 관심사에 주입
- `@SpringBootApplication` 또는 `@Configuration`을 명시한 클래스에 `@EnableAspectJAutoProxy`를 명시하면 Spring AOP 적용

스프링 AOP에서는 호출하는 쪽에서나 호출당하는 쪽, 누구도 프록시가 존재하는지 모른다. 오직 스프링 프레임워크만 프록시의 존재를 안다.

스프링 AOP 핵심

- 스프링 AOP는 인터페이스 기반이다.
- 스프링 AOP는 프록시(proxy) 기반이다.
- 스프링 AOP는 런타임 기반이다.



### Spring AOP, AspectJ

- Spring AOP는 개발자가 마주한 공통적인 문제를 해결하고자 Spring IoC를 통한 간단한 AOP 구현이 목적이다.
  - 완전한 AOP를 의도한 것이 아니며, Spring Container에 의해 관리되는 Bean 들에만 적용이 가능하다.
- AspectJ는 완전한 AOP를 제공하는 것이 목적인 근원적인 AOP 기술이다.
  - Spring AOP보다 강력하지만 복잡하다.
  - **모든 객체에 적용이 가능**하다.



### Spring AOP가 제공하는 두 가지 AOP Proxy

- JDK Dynamic Proxy

  - Java의 리플렉션 패키지에 존재하는 Proxy라는 클래스를 통해 생성된 Proxy 객체를 의미한다.

  - Proxy를 생성하는 과정에서 핵심적인 부분은, 무엇보다 인터페이스를 기준으로 Proxy 객체를 생성해준다는 점이다. 따라서 구현체는 인터페이스를 상속받아야하고, @Autowired를 통해 생성된 Proxy Bean을 사용하기 위해선 반드시 인터페이스의 타입으로 지정해줘야 한다.

  - 자바의 Reflection(런타임)을 활용하여 Proxy를 동적으로 구현하기 때문에 리소스 부담이 높고 성능이 떨어진다.

    > Reflection - 런타임에 실행해야 하는 클래스를 알게 되어 그 클래스의 메소드, 타입, 변수들에 접근하게 해주는 Java API

- CGLib

  - Spring은 CGLib을 사용하여 인터페이스가 아닌 타깃의 클래스에 대해서도 Proxy를 생성한다.
  - CGLib은 Final 메소드 또는 클래스에 대해 재정의를 할 수 없으므로 Proxy를 생성할 수 없다는 단점이 있지만, CGlib은 바이트 코드로 조작하여 Proxy를 생성해주기 때문에 성능에 대한 부분이 JDK Dynamic Proxy보다 좋다.
  - 성능의 차이의 근본적인 이유는 CGLib은 타깃에 대한 정보를 제공받기 때문이다.

> Spring AOP는 사용자의 특정 호출 시점에 IoC 컨테이너에 의해 AOP를 할 수 있는 Proxy Bean을 생성해준다. 동적으로 생성된 Proxy Bean은 타깃의 메소드가 호출되는 시점에 부가기능을 추가할 메소드를 자체적으로 판단하고 가로채어 부가기능을 주입주는데, 호출 시점에 동적으로 위빙을 한다 하여 **런타임 위빙(Runtime Weaving)**이라고 한다.

Spring은 AOP Proxy를 생성하는 과정에서 자체 검증 로직을 통해 타깃의 인터페이스 유무를 판단한다.

> Target : 횡단기능(Advice)이 적용될 객체(Object)

만약 타깃이 하나 이상의 인터페이스를 구현하고 있는 클래스라면 JDK Dynamic Proxy의 방식으로 생성되고 인터페이스를 구현하지 않은 클래스라면 CGLIB의 방식으로 AOP 프록시를 생성해준다.

CGLib의 한계와 해결

- Spring에서 기본적으로 지원하지 않는 방식이었기 때문에 별도로 **의존성을** **추가하여** 개발했다. 
  - -> [Spring 3.2](https://docs-stage.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-api) 버전부터 CGLib을 Spring Core 패키지에 포함시켜 더이상 의존성을 추가하지 않아도 개발할 수 있게 되었다.
- CGLib을 구현하기 위해선 반드시 파라미터가 없는 **default** **생성자가** 필요했다.
  - -> 4 버전에서 [Objensis 라이브러리](http://objenesis.org/)의 도움을 받아 default 생성자 없이도 Proxy를 생성할 수 있게 되었다.
- 생성된 CGLib Proxy의 메소드를 호출하게 되면 **타깃의** **생성자가** **2번** 호출된다는 단점이 존재했다.
  - -> 4 버전에서 생성자가 2번 호출되던 상황도 같이 개선이 되었다.

=> 세 가지 한계점이 모두 개선되어 Spring Boot에선 기본 Proxy 생성 방법으로 사용하고 있다.

> 참고 : https://gmoon92.github.io/spring/aop/2019/04/20/jdk-dynamic-proxy-and-cglib.html



### 용어

- Pointcut - Aspect 적용 위치 지정자

  - 횡단 관심사를 적용할 타깃 메서드를 선택하는 지시자(메서드 선택 필터)
  - 타깃 클래스의 타깃 메서드 지정자
  - 메서드 선정 알고리즘이라고도 한다.
  - 정규식, AspectJ 표현식 사용
  - `[접근제한자패턴] 리턴타입패턴 [패키지&클래스패턴.]메서드이름패턴(파라미터패턴) [throws 예외패턴]`

- JoinPoint - 연결 가능한 지점

  - Pointcut은 JoinPoint의 부분 집합

  - Pointcut의 후보가 되는 모든 메서드들이 JointPoint, 즉 Aspect 적용이 가능한 지점이 된다.

  - Aspect 적용이 가능한 모든 지점을 말한다.

  - 광의의 JoinPoint : Aspect 적용이 가능한 모든 지점

  - 협의의 JoinPoint : 호출된 객체의 메서드

    > JointPoint - 클래스 단위 / Pointcut - 메서드 단위 로 이해

- Advice - 언제, 무엇을

  - Pointcut에 언제, 무엇을 적용할지 정의한 메서드
  - 타깃 객체의 타깃 메서드에 적용될 부가 기능

- Aspect - Advisor의 집합체

  - 여러 개의 Advice와 여러 개의 Pointcut의 결합체
  - Aspect = Advice들 + Pointcut들

- Advisor - 어디서, 언제, 무엇을

  - Advisor = 한 개의 Advice + 한 개의 Pointcut
  - 스프링 AOP에서만 사용하는 용어, 다른 AOP 프레임워크에서는 사용하지 않는다.
  - 스프링 버전이 올라가면서 이제는 쓰지 말라고 권고하는 기능(deprecated)
  - Aspect가 나왔기 때문에 Advisor를 사용할 필요가 없어졌기 때문



```java
// Pointcut 중복 제거
@Component
@Aspect
public class MyAsepct {
  @Pointcut("execution(* runSomething())")
  private void iampc() {
    // 여긴 무엇을 작성해도 의미가 없어요
  }
  
  @Before("iampc()")
  public void before(JoinPoint joinPoint) {
    System.out.println("얼굴 인식 확인 : 문 개방");
  }
  
  @Before("iampc")
  public void lockDoor(JoinPoint joinPoint) {
    System.out.println("문 잠김");
  }
}
```



## PSA - 일관성 있는 서비스 추상화

- 서비스 추상화 예 - JDBC -> 데이터베이스 종류에 관계없이 같은 방식으로 제어할 수 있다.
- 어댑터 패턴을 적용해 같은 일을 하는 다수의 기술을 공통의 인터페이스로 제어할 수 있게 한 것을 서비스 추상화라고 한다.
- 스프링 프레임워크는 서비스 추상화를 위해 다양한 어댑터를 제공한다. 
- 스프링은 제각각인 API를 위한 어댑터를 제공함으로써 어떤 기술을 쓰든 일관된 방식으로 코드를 작성할 수 있게 지원한다. 서비스 추상화를 제공해주면서 일관성 있는 방식을 제공한다고 하여 PSA라고 한다.
- 스프링은 OXM, ORM, 캐시, 트랜잭션 등 다양한 기술에 대한 PSA를 제공한다.

