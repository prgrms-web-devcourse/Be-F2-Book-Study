# CH4

## 1. abstract 키워드 - 추상 메서드와 추상 클래스

- 추상 메서드 : 선언부는 있는 데 구현부가 없는 메서드
    
    → 추상메서드를 하나라도 갖고 있는 클래스는 반드시 추상 클래스로 선언해야 한다.
    
    → 즉, 추상 메소드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상 메소드를 구현하도록 강제 하기 위함
    
- 추상 클래스 : 추상 클래스는 인스턴스, 즉 객체를 만들 수 없다.

[추상클래스와 인터페이스 차이점](https://www.notion.so/55c7f8f74bdc4f80a2bb6443c5dc31b2)

## 2. 생성자

```jsx
Animal lion = new Animal();
```

new Animal() : 반환값이 없고 클래스 명과 같은 이름을 가진 메서드를 객체를 생성하는 메서드라고 해서 객체 생성자 메서드라 한다. *이를 줄여서 생성자라 부른다.*

→ 클래스에 *아무런 생성자 메서드가 없다면* 컴파일 과정에서 자바 컴파일러가 알아서 기본 생성자를 만들어 준다. 

생성자는 개발자가 필요한 만큼 오버로딩해서 만들 수 있다.

## 3. 클래스 생성 시의 실행 블록, static 블록

클래스가 스태틱 영역에 배치될 때 한번만 실행되는 코드 블록

```jsx
class Human {

        static int count=99999999;
        static {
            System.out.println("static block called 1");
            count=0
            Hello();

        }
        static {
            System.out.println("static block called 2");
            count=0;
            Hello();

        }
        public Human(){
            count ++;
            System.out.println("human : "+count);
        }
        private static void Hello() {
            System.out.println("hello");
        }
}   
```

- static 블록에서 사용할 수 있는 속성과 메소드는 static 멤버뿐이다.
    
    → static 블록이 실행되고 있을 때에는 아직 객체가 힙 메모리에 존재 하지 않기 때문
    
- 인스턴스를 여러개 만들어도   static 블록은 단 한번만 실행
- 주로 클래스 변수를 초기화 시키는 코드를 둔다.
- 클래스가 제일 처음 사용하는 3가지 경우는,
    - 클래스의 정적 속성을 사용할 때 : Human.count
    - 클래스의 정적 메서드를 사용할때  : Human.hello()
    - 클래스의 인스턴스를 최초로 만들 때 : new Human()
- 여러 개의 static 블록을 둘 수 있고 순서대로 실행된다.

*인스턴스 블록도 존재,*

- 아무런 표시 없이 {} 블록을 사용
- 인스턴스가 생성될 때마다 실행
- 객체 생성자가 실행 되기 전에 먼저 실행

전체 실행 순서 : static 블록 (순서대로 실행) → 인스턴스 블록 → 생성자 

## 4. final 키워드

final 키워드는 클래스, 변수, 메서드 딱 세부분에만 지정할 수 있다.

- final 클래스 : 상속을 허락하지 않겠다는 의미
    
    ```jsx
    public final class Cat {}
    ```
    
- final 변수 : 변경 불가능한 상수를 의미
    
    ```jsx
    final String name = "김선호";
    final int age; // 2
    ```
    
    → final 변수를 선언 시 직접 초기화 하지 않았다면 *(2)* 반드시 생성자 또는 인스턴스 및 static 블록에서 초기화 해줘야 하며 최초 한번만 초기화 가능하다.
    
- final 메서드 : 오버라이딩을 금지

```jsx
final void sayHi() { System.out.println("Hi~"); }
```

## 5. instanceof 연산자

인스턴스가 특정 클래스의 인스턴스인지 물어보는 연산자로 true , false 를 반환

→ 객체_참조_변수 instanceof 클래스명

→ 객체 참조 변수의 타입이 아닌 실제 객체의 타입에 의해 처리 

- 상속 관계 , 인터페이스의 구현 관계에서도 상위 클래스 와 비교한다면 true 반환

## 6. interface 키워드와 implements 키워드

interface는 public 추상 메서드와 public 정적 상수만 가질수 있다.

→ 메서드에 public abstract, 속성에 public static final 을 붙이지 않아도 자동으로 자바가 알아서 붙여준다.

```jsx
interface Speakable {
	double PI = 3.14159; // public static final double PI = 3.14159;
	
	void sayYes(); // public abstract void sayYes();
}
```

인터페이스의 디폴트 메소드와 정적 추상 메서드 → Java8부터 지원

```jsx
public interface Calculator {
        public int plus(int i, int j);
        default int multiply(int i, int j){
            return i * j;
        }
        public static int divide(int i, int j){ 
            return i / j;
        }
    }  

    public class MyCalculator {
        public static void main(String[] args){
            Calculator cal = new MyCalculator();
            int value = cal.multiply(5, 10);
            System.out.println(value);

            int value2 = Calculator.divide(5, 10);  //static메소드 호출 
            System.out.println(value2);
        }
    }
```

## 7. this 키워드

객체가 자기 자신을 지칭할때 쓰는 키워드 

- 지역 변수와 이름이 동일한 속성(객체 변수, 지역변수)가 존재할때  지역변수가 우선권이 있으므로 지역변수의 값이 출력된다.
    
    → 위와 같은 경우 정적 변수를 사용하려면 클래스 명을 접두사로 사용 
    
    ex) ClassName.변수명
    
    → 객체 변수를 사용 하려면 this를 사용 ex) this.변수명
    

## 8. super 키워드

바로 위 상위 클래스의 인스턴스를 지칭하는 키워드 

→ ex) super.변수명 상위 클래스의 객체변수 참조

→ super.super 형태로 상위의 상위 클래스의 인스턴스에는 접근이 불가능

→ super()는 부모 클래스의 생성자를 호출하는 메서드