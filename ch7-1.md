## IoC/DI - 제어의 역전/의존성 주입

### 프로그래밍에서 의존성이란?

의존성은 new다.

전체가 부분에 의존한다고 표현할 수 있다. (의존하는 객체(전체)와 의존되는 객체(부분) 사이에 집합 관계(Aggregation)와 구성 관계(Composition)로 구분할 수도 있지만)

**프로그래밍에서 의존 관계는 new로 표현된다!**

> 사실 변수에 값을 할당하는 모든 곳에 의존 관계가 생긴다. 지역 변수이건 속성이건, 할당되는 값이 리터럴이건 객체이건 의존은 발생한다. 의존 대상이 내부에 있을 수도 있고, 외부에 있을 수도 있다.

> 집합 관계 : 부분이 전체와 다른 생명 주기를 가질 수 있다. (집-냉장고)
>
> 구성 관계 : 부분은 전체와 같은 생명 주기를 갖는다. (사람-심장)

### 스프링 없이 의존성 주입하기 1 - 생성자를 통한 의존성 주입

```java
Tire tire = new KoreaTire();
Car car = new Car(tire) // 생성자에 인자로 주입
```

- Car에서 구체적으로 특정 Tire를 생산 - 유연성이 떨어지는 코드 -> 운전자가 어떤 타이어를 장착하게 할까 고민하게 하는 것으로

의존성 주입을 적용할 경우 Car는 그저 Tire 인터페이스를 구현한 어떤 객체가 들어오기만 하면 정상적으로 작동하게 된다.

의존성 주입을 하면 **확장성**도 좋아지는데, 어떤 새로운 타이어 브랜드가 생겨도 각 타이어 브랜드들이 Tire 인터페이스를 구현한다면 Car.java 코드를 변경할 필요 없이 사용할 수 있기 때문이다.(다시 컴파일할 필요도 없다.)

### 스프링 없이 의존성 주입하기 2 - 속성을 통한 의존성 주입

```java
Tire tire = new KoreaTire();
Car car = new Car();
car.setTire(tire); // set 메소드를 통해 의존성 주입
```

### 스프링을 통한 의존성 주입 - XML 파일 사용

스프링을 통한 의존성 주입은 생성자를 통한 의존성 주입과 속성을 통한 의존성 주입을 모두 지원

ApplicationContext : 스프링 프레임워크에 대한 정보를 가지고 있다.

XML 파일 - 빈 설정 파일 -> 스프링 프레임워크는 빈들을 빈 설정 파일로 모두 관리하여 의존성을 여기서부터 가져와서 교체할 수 있다.

스프링을 도입해서 얻는 이득 : 의존성들을 변경할 때 재컴파일/재배포하지 않아도 XML 파일만 수정하면 프로그램의 실행 결과를 바꿀 수 있다.

### 스프링을 통한 의존성 주입 - 스프링 설정 파일(XML)에서 속성 주입

자바 코드와 XML 설정을 익혀야 하는 부담이 있긴 하지만 더욱 현실적인 내용을 반영하기에 이해하기 쉽고 유지보수하기 편한 방식

### 스프링을 통한 의존성 주입 - @Autowired를 통한 속성 주입

`import`문 하나와 `@Autowired` 어노테이션을 이용하면 설정자 메서드를 이용하지 않고도 스프링 프레임워크가 설정 파일을 통해 설정자 메서드 대신 속성을 주입해 준다.

@Autowired의 의미 : 스프링 설정 파일을 보고 자동으로 속성의 설정자 메서드에 해당하는 역할을 해주겠다ㅅ

type 기준 매칭 - 같은 타입을 구현한 클래스가 여러 개 있다면 그때 bean 태그의 id로 구분해서 매칭하게 된다. id와 type 중 **type 구현에 우선순위**가 있다.

### 스프링을 통한 의존성 주입 - @Resource를 통한 속성 주입

@Autowired는 스프링 어노테이션 / @Resource는 자바 표준 어노테이션

스프링 프레임워크를 사용하지 않는다면 @Autowired는 사용할 수 없고 오직 @Resource만을 사용해야 한다.

@Resource의 경우 type과 id 가운데 매칭 우선순위는 id가 높다. 

@Resource의 경우 id로 매칭할 빈을 찾지 못한 경우 type으로 매칭할 빈을 찾게 된다.

- 스프링 프레임워크에서 @Autowired와 @Qualifier를 조합해서 사용
- @Resource에서 id가 필드 이름과 다른 빈을 이용해 속성 주입하기
- 자바 어노테이션 표준인 JSR-250과 JSR-330



## 정리

사실 변수에 값을 할당하는 모든 곳에 의존 관계가 생긴다. 지역 변수이건 속성이건, 할당되는 값이 리터럴이건 객체이건 의존은 발생한다. 의존 대상이 내부에 있을 수도 있고, 외부에 있을 수도 있다.

DI는 외부에 있는 의존 대상을 주입하는 것을 말한다. 의존 대상을 구현하고 배치할 때 SOLID와 응집도는 높이고 결합도는 낮추라는 기본 원칙에 충실해야 한다. -> 프로젝트의 구현과 유지보수가 수월해진다.



## 추가

### POJO (Paain Old Java Object)

추가 항목이 없는 단순한 객체. 객체 지향 원리에 충실하면서 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 객체

POJO는

- 클래스 확장

  ```java
  public class Foo extends javax.servlet.http.HttpServlet { ... // Foo - POJO X
  ```

- 인터페이스 구현

  ```java
  public class Bar implements javax.ejb.EntityBean { ... // Bar - POJO X
  ```

- Annotaion 포함

  ```java
  @javax.persistence.Entity public class Baz { ... // Baz - POJO X
  ```

을 하지 말아야한다.



### 의존성 주입의 세 가지 방법

- 생성자 주입
- 필드 주입
- Setter 주입

스프링 프레임워크 레퍼런스에서 권장하는 방법은 **생성자를 통한 주입**

- 컨테이너가 빈을 생성하는 시점에서 객체 생성에 사이클 관계가 생기기 때문에 컴파일 시점에 순환 참조 문제를 발견할 수 있다. - 앱 구동 실패
- 의존 관계 설정이 되지 않으면 객체 생성이 불가능하다. -> NPE 방지
- final 선언이 가능하다. -> 객체 불변성을 확보할 수 있다.
- 테스트 코드 작성이 용이하다. 원하는 객체를 생성한 후 생성자에 넣어주면 된다. (필드 주입이나 Setter 주입은 Mockito를 이용해 모킹 후 테스트 진행)